# C-To-Java
Compiling C into Java via CIL by using a CIL pass written in OCaml.
CO620 research project supervised by @stephenrkell investigating runtime speeds from single program transformation into Java when compared to other

## Getting Started
This project is not particulary trivial to setup as of now and is not recommended for beginners. I hope to make some build scripts (probably make) to automate the setup and running however this is currently still to be seen.

1. Install dependancies
  This project relies heavily on a modified driver for CIL called cilpp which is located in the toolsub repo (https://github.com/stephenrkell/toolsub) as well as a few more utilities in liballocs (https://github.com/stephenrkell/liballocs) and libcrunch (https://github.com/stephenrkell/libcrunch) which should all be downloaded and installed correctly, according to the intstructions on the relevant pages, before C-To-Java.
  
2. Clone C-To-Java (this repo)
  Clone into any new directory.
  ```bash
  $ git clone https://github.com/AmazingPie/C-To-Java.git
  ```

3. Copy C-To-Java into cilpp
  This project actually replaces the whole cilpp source file, by building upon it, and should be copied into the cilpp/src folder to overwrite the cilpp.ml and then uses the cilpp build system to transform files.
  ```bash
  $ cd C-To-Java/
  $ cp src/cilpp.ml path/to/cilpp/src/
  ```
  
4. Build cilpp
  Make sure to set the CIL_INSTALL location as the one in your liballocs directory.
  ```bash
  $ cd path/to/toolsub/cilpp/src
  $ CIL_INSTALL=path/to/liballocs/tools/lang/c/cil/lib make   (might need to run this with admin privilages)
  ```
  
5. Run cilpp on a source file
  ```bash
  $ cd path/to/toolsub/cilpp/src
  $ gcc `./../bin/cilpp-cflags` -E path/to/file.c -o path/to/output_file.java -Wp,-plugin,path/to/liballocs/tools/lang/c/cilallocs/cilallocs.cmxs,-plugin,path/to/libcrunch/frontend/c/ptrintarith/ptrintarith.cmxs -Wp,-fpass-ptrintarith -std=c11
  ```

## Benchmarks
There are three sets of benchmarks all based from the same benchmark program just slightly modified to investigate the impacts of different sized programs on the runtime and performance of the generated Java code. Each program has a number of warm-up iterations (so that the JVM can warm up sufficently) which are not timed and a number of iterations that are timed.

The three types are:
  1. The original control set with 10,000 warm up iterations and 10,000 timed iterations
  2. Start Up (SU) set with 100,000 warm up iterations and 10,000 timed iterations
  3. Larger (L) set with 10,000 warm up iterations and 100,000 timed iterations

The benchmarks are implemented using three systems/languages: the original C program, the Java code generated by C-To-Java and the original C program compiled with address sanitiser (Asan).
