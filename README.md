# C-To-Java
Compiling C into Java via CIL by using a CIL pass written in OCaml.
CO620 research project supervised by @stephenrkell investigating runtime speeds from single program transformation into Java when compared to other methods.

This project is not complete and will fail for medium-large programs as many type transformations are not currently supported.

## Getting Started
This project is not particulary trivial to setup as of now and is not recommended for beginners.

**Edit:**
A build script has been made to automate the development process. This script is fairly basic but should help the (re)building process.

###Installation
1. Install dependancies
  This project relies heavily on a modified driver for CIL called cilpp which is located in the toolsub repo (https://github.com/stephenrkell/toolsub) as well as a few more utilities in liballocs (https://github.com/stephenrkell/liballocs) and libcrunch (https://github.com/stephenrkell/libcrunch) which should all be downloaded and installed correctly, according to the intstructions on the relevant pages, before C-To-Java.
  
2. Clone C-To-Java (this repo)
  Clone into any new directory.
  ```bash
  $ git clone https://github.com/AmazingPie/C-To-Java.git
  ```

###Using The Script (recommended)
3. Run build script
  This will rebuild CIL as well as transform the C source file into Java
  ```bash
  $ cd C-To-Java/
  $ ./make.sh /path/to/liballocs+libcrunch+toolsub ./examples/ptr.c
  ```

###Manually Building

3. Copy C-To-Java into cilpp
  This project actually replaces the whole cilpp source file, by building upon it, and should be copied into the cilpp/src folder to overwrite the cilpp.ml and then uses the cilpp build system to transform files.
  ```bash
  $ cd C-To-Java/
  $ cp src/cilpp.ml path/to/cilpp/src/
  ```
  
4. Build cilpp
  Make sure to set the CIL_INSTALL location as the one in your liballocs directory.
  ```bash
  $ cd path/to/toolsub/cilpp/src
  $ CIL_INSTALL=path/to/liballocs/tools/lang/c/cil/lib make   (might need to run this with admin privilages)
  ```
  
5. Run cilpp on a source file
  ```bash
  $ cd path/to/toolsub/cilpp/src
  $ gcc `./../bin/cilpp-cflags` -E path/to/file.c -o path/to/output_file.java -Wp,-plugin,path/to/liballocs/tools/lang/c/cilallocs/cilallocs.cmxs,-plugin,path/to/libcrunch/frontend/c/ptrintarith/ptrintarith.cmxs -Wp,-fpass-ptrintarith -std=c11
  ```

## Benchmarks
There are three sets of benchmarks all based from the same benchmark program just slightly modified to investigate the impacts of different sized programs on the runtime and performance of the generated Java code. Each program has a number of warm-up iterations (so that the JVM can warm up sufficently) which are not timed and a number of iterations that are timed.

The three types are:
  1. The original control set with 10,000 warm up iterations and 10,000 timed iterations
  2. Start Up (SU) set with 100,000 warm up iterations and 10,000 timed iterations
  3. Larger (L) set with 10,000 warm up iterations and 10,000,000 timed iterations

The benchmarks are implemented using three systems/languages: the original C program, the Java code generated by C-To-Java and the original C program compiled with address sanitiser (Asan).

To run each benchmark compile the code in the relevant folders using javac/gcc and then use the corresponding shell script 'run.sh' with an optional argument for the number of times you want to run each benchmark. Results will be dumped into corresponding text files in the results folder in the format '0.1234;0.2345;...'. Also note that Java will produce results in nanoseconds whereas C/ASan produces results in seconds instead.